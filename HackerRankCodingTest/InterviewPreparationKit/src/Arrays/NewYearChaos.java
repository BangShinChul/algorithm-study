package Arrays;

/*

link : https://www.hackerrank.com/challenges/new-year-chaos/problem?h_l=interview&playlist_slugs%5B%5D=interview-preparation-kit&playlist_slugs%5B%5D=arrays

새해 첫날에 원더 랜드 롤러 코스터를 타기위해 모두가 줄을 섰습니다.

대기중인 많은 사람들이 있으며,
각 사람은 대기열에서 초기 위치를 나타내는 스티커를 착용합니다.
초기 위치는 선의 앞쪽에서 1에서 뒤쪽의 n까지 1 씩 증가합니다.

대기열에있는 사람은 그 사람을 바로 앞에두고 뇌물을 교환 할 수 있습니다.
두 사람이 직위를 교환하는 경우 원래 위치를 나타내는 동일한 스티커를 착용합니다.
한 사람은 기껏해야 두 사람을 뇌물 수 있습니다.
예를 들어 n = 8이고 Person 5가 Person 4에게 뇌물을 제공하면 대기열은 1,2,3,5,4,6,7,8과 같습니다.

이 혼란스런 큐에 매료 된 당신은 큐를 현재 상태로 만들기 위해 발생 된 뇌물의 최소 수를 알아야한다고 결정했습니다!

- 함수 설명

아래 편집기에서 minimumBribes 함수를 완성하십시오.
필요한 최소한의 뇌물 수를 나타내는 정수를 인쇄해야하며, 회선 구성이 불가능한 경우 너무 혼란 스럽다.

minimumBribes에는 다음 매개 변수가 있습니다.

q : 정수 배열


- 입력 형식

첫 번째 행에는 테스트 케이스의 수인 정수가 포함됩니다.

다음 t 행 쌍 각각은 다음과 같습니다.
- 첫 번째 줄에는 정수 t, 대기열에있는 사람 수
- 두 번째 행에는 큐의 최종 상태를 설명하는 n 개의 공백으로 구분 된 정수가 있습니다.


- 제약 조건

1 <= t <= 10
1 <= n <= 10의 5승

- 하위 작업

60%의 점수에 대해서 1 <= n <= 1000
100%의 점수에 대해서 1 <= n <= 100000


- 출력 형식

큐를 최종 상태로 만드는 데 필요한 최소 뇌물 수를 나타내는 정수를 인쇄합니다.
인쇄 상태가 유효하지 않은 경우 너무 혼란스럽습니다.
즉, 사람이 2 명 이상을 매수할 것을 요구합니다.


- 입력 샘플

2
5
2 1 5 3 4
5
2 5 1 3 4


- 출력 샘플

3
Too chaotic

- 예제 해석

초기 상태 :
Ride! 1 --- 2 --- 3 --- 4 --- 5

5번째 사람이 4번째 사람에게 뇌물을 주어 4번째 사람 앞으로 1을 이동:
Ride! 1 --- 2 --- 3 --- 5 --- 4

5번째 사람이 3번째 사람에게 뇌물을 주어 3번째 사람 앞으로 1을 이동:
Ride! 1 --- 2 --- 5 --- 3 --- 4

2번째 사람이 1번째 사람에게 뇌물을 주어 1번째 사람 앞으로 1을 이동:
Ride! 2 --- 1 --- 5 --- 3 --- 4

그래서 최종 상태는 3번의 뇌물 매매 작업 후에 2,1,5,3,4입니다.
어떤 사람도 두 명 이상의 사람을 매수할 수 없으므로 입력 상태를 달성 할 수 없습니다.

--
매개변수로 받은 int형 배열 처럼 모양을 만드려면
순서대로 있던 줄에서 얼마나 이동해야지 가능한지 최소 카운트 수를 반환하는 문제.
만약에 절대 못만드는 구조라면(왜냐하면 한명당 최대 이동 가능 거리 수가 2칸이기 때문)
Too Chaotic을 출력해야함.

예를 들어,
[1,2,3,4,5,6,7,8] 을
[5,1,2,3,7,8,6,4] 로 만들지 못하므로 Too Chaotic
[1,3,2,5,4,8,6,7] 로 만드려면 4번 이동하면 되므로 4 리턴.
1번째 2,3 자리교환
2번째 4,5 자리교환
3번째 7,8 자리교환
4번째 6,8 자리교환

* */
public class NewYearChaos {

    static void minimumBribes(int[] q) {
        int qLength = q.length;
        int cnt = 0;
        while (qLength != 0) {

        }

    }
}
